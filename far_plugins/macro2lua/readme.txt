Конвертер Macro2Lua
===================

Общая информация
----------------

Конвертер преобразует макросы с макроязыка в язык Lua 5.1.

Конвертер выполнен как плагин для Фар 3, т.к. используется фаровская
функция для верификации имён клавиш. Плагин использует библиотеку LuaFAR,
которая поставляется вместе с Фар 3.

Плагин обрабатывает XML-файлы формата экспорта Фар 3 и FML-файлы плагина
MacroLib. При успешном преобразовании, плагин создаёт выходной файл.

Плагин запускается с командной строки двумя способами:

(1)     M2L: convert <input file> <output file> [<syntax>]

<syntax> указывает синтаксис входного файла, может быть одним из:
        xml_file       -- XML файл (значение по умолчанию)
        xml_macros     -- секция <macros> в XML файле
        xml_keymacros  -- секция <keymacros> в XML файле
        xml_macro      -- секция <macro> в XML файле

        fml_file       -- FML файл
        fml_macro      -- секция Macro в FML файле

        chunk          -- "голый" макрос
        expression     -- выражение

При необходимости пакетной обработки можно воспользоваться командой
*Apply Command* (CtrlG).

(2)     M2L: run <script file> [<arguments>]

Плагин исполняет указанный Lua-скрипт и предоставляет ему глобальную функцию
`Convert`:

        str_out, str_message = Convert (str_syntax, str_in),

где `str_syntax` является одним из обозначений синтаксиса, используемых
в способе (1) вызова плагина (см. описание выше).

Вызов из макросов
-----------------
        local guid = "50b1abe5-91ba-478c-be2d-64366a81d47c"
        str_out, str_message = Plugin.Call(guid, str_syntax, str_in)

где `str_syntax` является одним из обозначений синтаксиса, используемых
в способе (1) вызова плагина (см. описание выше).

Экспортируемые функции
----------------------
intptr_t WINAPI ConvertChunk(const wchar_t *ChunkIn, wchar_t **ChunkOut); // возвращает TRUE/FALSE
void WINAPI FreeChunk(wchar_t *ChunkOut);

Что надо править вручную в преобразованных файлах
-------------------------------------------------
Данный конвертер не ставит перед собой цель, чтобы преобразованный файл сразу
заработал. Его цель - автоматизировать 90...95 процентов необходимых
преобразований. Оставшаяся часть преобразований должна выполняться
программистом.

1. Проверка результатов битовых операций.
         Неправильно: if band(c,0x10)
                      if not band(c,0x10)
         Правильно:   if band(c,0x10)~=0
                      if band(c,0x10)==0

2. Аналог оператора $CONTINUE отсутствует в Lua. Если он есть в макросе, надо
   перегруппировать код, например, вместо этого:
        while f() do
          chunk1
          if a > b then $continue end
          chunk2
        end
   пишем это:
        while f() do
          chunk1
          if a <= b then
            chunk2
          end
        end

3. Проверка и, возможно, исправление аргументов в вызовах функции eval.
   Например, конвертер преобразовал eval(%V) в eval(V), и это, на первый
   взгляд, правильное преобразование. Но работать не будет, если %V содержит
   код в формате макроязыка, а не Lua. Конвертер в общем случае не может знать,
   что содержит переменная %V, так как её содержимое формируется во время
   исполнения макроса, а не во время его преобразования.

4. Вставка опущенных аргументов при вызове функций, например:
       mf.strwrap("Пример строки",7,,1).
   Lua не позволяет опускать непоследние аргументы в списке, поэтому нужно
   вставить соответствующие значения (обычно это либо 0, либо "").

5. Оператор ^^ не имеет аналога в Lua. A^^B можно заменить на (A==0)~=(B==0).

X. Продолжение следует.
